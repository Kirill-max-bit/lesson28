# lesson28
**ВОПРОС1: Сложение и вычитаниеСложение и вычитание требуются не только для расчётов по формулам, но и для организации вычислений. Например, для того чтобы повторить какое-то действие R раз, используют переменную-счётчик, к которой после каждого выполнения этого действия прибавляют единицу, а затем результат сравнивают с R.**

**ВОПРО2: Дополнительный код – это система представления знаковых целых, упрощающая выполнение двоичной арифметики. Чтобы найти дополнительный код двоичного числа, вы инвертируете все его биты (изменяя 0 на 1 и наоборот), после чего прибавляете к результату единицу**

**ВОПРОС3: Анализом переносов, возникающих при сложении двоичных чисел. Признаками переполнения разрядной сетки являются либо наличие переноса в знаковый разряд при отсутствии переноса из разрядного знака**

**ВОПРОС4:Арифметико-логическое устройство (ALU) выполняет над данными основные арифметические (сложение, вычитание, умножение и деление) и логические операции (AND, OR и NOT). Оно получает данные из регистров процессора, обрабатывает их на основе инструкций блока управления и выдает результат.**

**ВОПРОС5:Создание специального устройства для вычитания целых чисел может показаться излишним по нескольким причинам:

1. **Базовые арифметические операции**: Вычитание целове чисел можно свести к другим базовым арифметическим операциям, таким как сложение. Например, вычитание числа B из числа A можно представить как сложение A и отрицательного B (то есть A - B = A + (-B)). Это позволяет использовать уже существующие устройства для сложения.

2. **Сложность и стоимость разработки**: Разработка специализированного оборудования для простой операции, такой как вычитание, может быть экономически нецелесообразной. Существующие процессоры и микроконтроллеры уже могут выполнять эти операции с достаточной скоростью и точностью.

3. **Универсальность**: Современные вычислительные системы и процессоры обычно имеют встроенные арифметические логические устройства (ALU), которые могут выполнять все основные арифметические операции, включая сложение, вычитание, умножение и деление. Это позволяет использовать одно устройство для выполнения нескольких операций, что упрощает архитектуру и повышает эффективность.

4. **Программное обеспечение**: Алгоритмы вычитания могут быть легко реализованы в программном обеспечении, что делает создание специализированного устройства ненужным. Современные языки программирования и компиляторы оптимизируют вычитание так же, как и другие арифметические операции.

Таким образом, вычитание целых чисел часто не требует разработки специального оборудования, так как существующие устройства и технологии уже эффективно справляются с этой задачей.

**ВОПРОС6:Легко проверить, что это число равно 4510.В сравнении с десятичной системой, здесь есть серьёзное упрощение: первый сомножитель умножается на единицу (в этом случае результат равен ему самому) или на ноль (результат — 0). Поэтому компьютерное умножение целых чисел состоит из следующих элементарных действий:**
**1)  вычисление очередного произведения в зависимости от младшего бита второго сомножителя: оно равно нулю (если этот бит нулевой) или первому сомножителю (если бит равен единице);2) сложение содержимого сумматора с очередным произведением;**
**3) сдвиг содержимого первого сомножителя влево на 1 разряд;4) сдвиг второго сомножителя вправо на 1 разряд (при этом следующий бит попадёт в младший разряд).**
**Таким образом, удаётся построить схему умножения без использования таблицы умножения. Заметим, что умножение — это довольно трудоёмкая операция, и для её ускорения конструкторы используют различные «хитрые» приёмы. Поэтому в реальных компьютерах всё может выглядеть** **значительно сложнее, чем в учебном примере.Умножение, как и сложение, выполняется одинаково для положительных и отрицательных чисел (в дополнительном коде). Если в нашем примере вместо числа 9 подставить -9, то получится:**

**ВОПРОС7: Например, для беззнаковых чисел 8116 (12910) больше, чем 7F16 (12710). Для чисел со знаком, наоборот, отрицательное значение 8116 (—12710) будет меньше, чем 7F16 (12710). Поэтому современные процессоры имеют разные команды для сравнения чисел со знаком и без знака.**

**ВОПРОС8: Поразрядная конъюнкция – это логическая операция, которая выполняется над цифрами чисел, записанных в двоичной системе счисления. Нули и единицы в двоичной записи при этом воспринимаются как логические нули и единицы.**

**ВОПРОС9: Нельзя, потому что у поразрядных действия совершаются над каждым разрядом в отдельности, независимо друг от друга**

**ВОПРОС10: Маска — это последовательность букв, цифр и других допустимых в именах файлов символов, в которых также могут встречаться следующие символы: символ «?» (вопросительный знак) означает ровно один произвольный символ; символ «*» (звёздочка) означает любую последовательность символов произвольной длины, в том числе «*»

**ВОПРОС11:Для сброса конкретного бита, не трогая другие, нужно выполнить битовое AND с маской типа 11111011. А маску такую чтобы сделать - можно, например, выполнить сдвиг единицы влево, затем инвертировать**

**ВОПРОС12:Будем применять логические операции к каждому биту числа, как обычно считая, что 1 соответствует значению «истина», а 0 — «ложь». Эти операции часто называют поразрядными или битовыми, поскольку действия совершаются над каждым разрядом в отдельности, независимо друг от друга.
Введём несколько терминов, которые используются в литературе по вычислительной технике. Сброс — это запись в бит нулевого значения, а установка — запись единицы. Таким образом, если бит в результате какой-то операции становится равным нулю, то говорят, что он сбрасывается. Аналогично, когда в него записана единица, говорят, что бит установлен.**

**ВОПРОС13:Для сброса конкретного бита, не трогая другие, нужно выполнить битовое AND с маской типа 11111011. А маску такую чтобы сделать - можно, например, выполнить сдвиг единицы влево, затем инвертировать**

**ВОПРОС14:Сравнение
В отличие от арифметических действий операция сравнения по-разному выполняется для чисел со знаком и без него. Еще раз внимательно посмотрим на таблицы кодов 8-битных чисел, при¬ведённые в § 27 (табл. 4.4). Если сравниваемые коды не превышают 7F16, то оба числа положительны а сравнение однозначно. Если это не так, то сравнение чисел с учётом и без учёта знака дает разные результаты. Например, для беззнаковых чисел 8116 (12910) больше, чем 7F16 (12710). Для чисел со знаком, наоборот, отрицательное значение 8116 (-12710) будет меньше, чем 7F16 (12710). Поэтому современные процессоры имеют разные команды для сравнения чисел со знаком и без знака. Чтобы не путаться, при сравнении с учётом знака обычно используют термины «больше» /«меньше», а при сравнении без учёта знака — «выше » / «ниже».**

**ВОПРОС15:Натуральное число делится на 8 тогда и только тогда, когда число, образованное его тремя последними цифрами (в том же порядке), делится на 8.**

**ВОПРОС16:Будем пользоваться шестнадцатеричными кодами: как видно из та
блицы, их связь с цифрами числа гораздо нагляднее. Чтобы получить числовое значение цифры из кода символа X, достаточно сбросить его старшие четыре бита, не изменяя значений четырёх младших битов. Для этого нужно использовать операцию X and 0F16.Пусть Sj — код первого введённого символа, S2 — второго, S3 — третьего, а N обозначает искомое число. Тогда алгоритм перевода кодов символов в число выглядит так:
 l.N=0.2.W = S-i and 0F16 (выделяем первую цифру).
3.N -10 - N + W (добавляем её к числу).4.W = S2 and 0F16 (выделяем вторую цифру).
5.N = 10 -N + W (добавляем её к числу).6.W = S3 and 0F16 (выделяем третью цифру).
7.N =10N + W (добавляем её к числу).Пусть, например, набраны символы '1', '2' и '3'. Тогда по таблице находим, что S1 =3116, S2 =3216 и S3 =3316. Значение W на втором шаге вычисляется так:**

**ВОПРОС17:возвращает значение Истины только в том случае, если один из аргументов имеет значение Истина.**

**ВОПРОС18:Исключающее ИЛИ. Как видно из таблицы истинности, операция «исключающее ИЛИ» (xor) не изменяет биты, когда маска нулевая, и меняет биты на противоположные при единичной маске (рис. 4.15). 
Например, команда X = X xor FF16 выполняет инверсию всех битов 8-разрядного целого числа. Напомним, что это один из этапов получения дополнительно¬го кода отрицательных чисел.С помощью логической операции «исключающее ИЛИ" можно выполнить инверсию отдельных битов числа (тех, для которых маска единичная), не меняя значения остальных битов (для которых в маске стоят нули).
Пример 3. Пусть .X" — это результат выполнения некоторого вычислительного теста, а У — то, что ожидалось получить («правильное» значение). Нужно определить, в каких разрядах разли¬чаются эти числа (для инженера это очень полезная подсказка,
Предположим, что Х = 7, У = 3. В результате операции X xor У устанавливаются (в единицу) только те разряды, которые вэтих числах не совпали, а остальные сбрасываются1. В данном случае находим, что числа различаются только одним битом:**

**ВОПРОС19:Логическое «НЕ»  (инвертирование, инверсия, not) — это замена всех битов числа на обратные значения: 0 на 1, а 1 — на 0. Эта операция используется, например, для получения дополнительного кода отрицательных чисел (см. алгоритм А1 в § 27). «НЕ» — это унарная операция, т. е. она действует на все биты одного числа. Маска здесь не используется.
 Логическое «И» (and). Обозначим через D содержимое некоторого бита данных, а через М — значение соответствующего ему бита маски. Операция «И» между ними задаётся таблицей, показанной на рис. 4.12.
Из таблицы видно, что при выполнении логического «И» нулевой бит в маске всегда сбрасывает (делает равным нулю) соответствующий бит результата, а еди-**

**ВОПРОС20:Дополнительный код — наиболее распространённый способ представления отрицательных целых чисел в компьютерах. Он позволяет заменить операцию вычитания на операцию сложения и сделать операции сложения и вычитания одинаковыми для знаковых и беззнаковых чисел, чем упрощает архитектуру ЭВМ.
Дополнительный код отрицательного числа можно получить инвертированием модуля двоичного числа (первое дополнение) и прибавлением к инверсии единицы (второе дополнение), либо вычитанием числа из нуля. Дополнительный код (дополнение до 2) двоичного числа получается добавлением 1 к младшему значащему разряду его дополнения до 1. 
Дополнение до 2 двоичного числа определяется как величина полученная вычитанием числа из наибольшей степени двух (из 2N для N-битного дополнения до 2). При записи числа в дополнительном коде старший разряд является знаковым.**

**ВОПРОС21:Би́товый сдвиг — изменение позиций бит в машинном слове.
Большинство компьютеров не могут напрямую адресовать биты, которые содержатся группами по 8, 16, 32 или 64 бита в машинном слове. Для обеспечения работы с битами существует множество машинных инструкций, включающие различные типы сдвигов. Все сдвиги похожи друг на друга поведением
, 8 ,16 все они делятся нацело на 4
13 Х and 1 = 0, X and 7 = 0, X and F=014 а:=а xor b: b:=b xor a; a:=a xor b
15 R:=x shr 16; Q:=(x shr 8) & F_16; B:=X & F_1616 Правильны оба решения, но у Коли рациональнее
17 Y:=(X shl 4) shr 4; Z:=(X shr 4) shl 418 При использовании 16-битных данных: EDCO_16? EDCF_16
19 При использовании 16-битных данных: 0123_16, 4123_16, 0123_16, 0FED_16, FFED_1620 Дополнительный код для отрицательного числа можно получить инвертированием его двоичного модуля (получается "первое дополнение") и прибавлением к инверсии единицы (получается "второе дополнение"), либо вычитанием числа из нуля (сразу получается "второе дополнение").
Дополнительный код двоичного числа определяется как величина, полученная вычитанием числа из наибольшей степени двух (из 2
N{\displaystyle 2^{N}} для 
N{\displaystyle N}-битного второго дополнения).
21 Z= 1100_2 = 12
22 Z= 1100_2 = 12Z= shl 1 = 11000_2
X = Z = 11000_2X = X shl 2 = 1100000_2
X = X + Z = 1111000_2 = 120**

**ВОПРОС22:Сдвиг (геология) — разрывное нарушение с преимущественно горизонтальным смещением крыльев. Сдвиг (механика) — механическая деформация, вызванная касательными напряжениями. Сдвиг (стиховедение) — фонетическое явление в художественной речи, преимущественно в стихе, родственное омонимии.Примеры:Сдвиг фаз — разность между начальными фазами двух переменных величин, изменяющихся во времени периодически с одинаковой частотой. Битовый сдвиг — изменение позиций битов в слове на одну и ту же величину. Лэмбовский сдвиг — сдвиг энергии связи электрона в атоме водорода.**

**ВОПРОС23:При сдвиге битов в двоичных числах выделяют два основных типа сдвига: логический и арифметический. Они обрабатывают самый старший (старший бит, MSB) и самый младший бит (младший бит, LSB) по-разному.**

### 1. Логический сдвиг (Logical Shift)

**-Левый логический сдвиг (Left Logical Shift)**:
 **- Каждой бит в числе сдвигается на одну позицию влево.**
  **- Самый младший бит (LSB) при этом заполняется нулем.**
 **- Самый старший бит (MSB) выталкивается и теряется.**
  **- Пример:**
    - 0101 (5) << 1 = 1010 (10)**

- **Правый логический сдвиг (Right Logical Shift)**:
  **- Каждой бит в числе сдвигается на одну позицию вправо.**
  **- Самый старший бит (MSB) заполняется нулем.**
  **- Самый младший бит (LSB) выталкивается и теряется.**
  **- Пример:
    - 1010 (10) >> 1 = 0101 (5)**

**### 2. Арифметический сдвиг (Arithmetic Shift)**

- **Левый арифметический сдвиг (Left Arithmetic Shift):**
  **-Функционирует так же, как левый логический сдвиг: старшие биты сдвигаются влево, а LSB заполняется нулем.**
  **-MSB теряется.**
  **-Пример:**
    **-0101 (5) << 1 = 1010 (10)

- **Правый арифметический сдвиг (Right Arithmetic Shift)**:
  - При сдвиге вправо, LSB выталкивается и теряется.
  - MSB остается неизменным (если это знаковое число, используется его значение для дополнения; если это положительное число, заполняется нулями, если отрицательное, то единицами).
  - Пример:
    - 1010 (число -6 в двоичном представлении с дополнительным кодом) >> 1 = 1101 (число -3 в двоичном представлении с дополнительным кодом)

**### 3. Циклический сдвиг (Rotation)**

- **Циклический сдвиг**:
  - В этом случае LSB или MSB не теряются, а просто перемещаются с одной стороны числа на другую.
  - При левом циклическом сдвиге LSB оказывается в начале, а при правом циклическом сдвиге MSB появляется в конце.
  - Пример:
    - Левый циклический сдвиг: 1010 --> 0101
    - Правый циклический сдвиг: 1010 --> 0101

**Таким образом, обработка старшего и младшего битов зависит от типа сдвига. Логические сдвиги заменяют выброшенные биты нулями, арифметические сдвиги сохраняют знак числа, а циклические сдвиги не теряют биты вообще.**

**ВОПРОС24:Сдвиг битов влево и вправо действительно имеет математический смысл в контексте двоичных чисел. Давайте рассмотрим несколько примеров для лучшего понимания того, как это работает.**

**### Сдвиг влево (Left Shift)**

Сдвиг двоичного числа влево на одну позицию удваивает его значение. Это связано с тем, что при сдвиге каждая цифра перемещается на одну позицию влево, и таким образом фактически увеличивается порядок числа, что равносильно умножению на 2.

**Примеры**:

1. **Двоичное число `0001` (1 в десятичной системе)**:
   - `0001` &lt;&lt; 1 = `0010` (это 2 в десятичной системе)

2. **Двоичное число `0010` (2 в десятичной системе)**:
   - `0010` &lt;&lt; 1 = `0100` (это 4 в десятичной системе)

3. **Двоичное число `0101` (5 в десятичной системе)**:
   - `0101` &lt;&lt; 1 = `1010` (это 10 в десятичной системе)

**Таким образом, каждый раз при сдвиге влево на одну позицию число удваивается.**

**### Сдвиг вправо (Right Shift)**

**Сдвиг двоичного числа вправо на одну позицию уменьшает его значение вдвое. Это также связано с тем, что при сдвиге каждая цифра перемещается на одну позицию вправо, что фактически уменьшает порядок числа, равносильно делению на 2.**

**Примеры**:

1. **Двоичное число `0010` (2 в десятичной системе)**:
   - `0010` &gt;&gt; 1 = `0001` (это 1 в десятичной системе)

2. **Двоичное число `0100` (4 в десятичной системе)**:
   - `0100` &gt;&gt; 1 = `0010` (это 2 в десятичной системе)

3. **Двоичное число `1010` (10 в десятичной системе)**:
   - `1010` &gt;&gt; 1 = `0101` (это 5 в десятичной системе)

**Таким образом, каждый раз при сдвиге вправо на одну позицию число уменьшается вдвое.**


**ВОПРОС25:Логический сдвиг не подходит для уменьшения отрицательных чисел вдвое из-за того, как он обрабатывает бит знака в знаковых числах. Давайте рассмотрим это подробнее.**

**### Логический сдвиг**

**Логический сдвиг вправо перемещает все биты числа вправо на указанное количество позиций, заполняя освободившиеся места нулями. Это приводит к тому, что бит знака (MSB, который указывает на знак числа в двоичном представлении) изменяется. Для положительных чисел это может быть приемлемо, но для отрицательных чисел — нет.**

**#### Пример:**

**Предположим, у нас есть 8-битное целое число -5. В двоичном представлении это выглядит как:
-5 (в дополнительном коде) = 11111011
Если мы применим логический сдвиг вправо:
11111011 >> 1 = 01111101
Теперь мы получили `01111101`, что в десятичной системе составляет 125, что совершенно не соответствует ожиданиям, поскольку было ожидаемо, что результат будет равен -3. Это произошло, потому что логический сдвиг не сохраняет информацию о знаке.**


**ВОПРОС26:В программировании арифметический сдвиг — это оператор сдвига, иногда называемый сдвигом со знаком (хотя он не ограничивается знаковыми операндами). Двумя основными типами являются арифметический сдвиг влево и арифметический сдвиг вправо.**


**ВОПРОС27:Что-то пошло не так. Попробуйте повторить запрос через пару минут. Если не помогает, создайте новый чат. Также отключите VPN и блокировщик рекламы, если включены. Если все из перечисленного не помогает, попробуйте воспользоваться сервисом через другой браузер.**

**ВОПРОС28:Применяются в языках программирования и цифровой технике**

**№ЗАДАЧИ:**

**1-00011111 + 00010011 = 00110010
2-11100001 + 00010011 = 11110100**

3-0

4-1011111 ; 11011111

5-1100 * 111 = 1010100

6-11110100 * 111 = 10101100

7-Коля просто догодался пременить переместительный закон для умножения

8-119 и 136 , 119 и -120

9-код заглавиой = код строчной abdF16

10-код cтрочной = код загалавной or2016

11-Решение коли приводит к неправильным ответам , когда сумма цифр больше 15

12-4 , 8 , 16 - все они деляться на число 4

13X and 1=0 , X and 7=0 , X and F = 0

14a: = a xor b ; b:= b xor a ; a:= a xor b

15R: = x Shr 16 ; 6: = ( X Sbr 8 ) 8 F16 ; B: = x

16правильны оба

17y : = ( X Shi4 ) Shr4 ; z:= ( X Shr4 ) Shi4

18при использовании 16 - битных данных : EDCO16 , EDF16

`19при использовании 16 - битных данных : 0123(16) 4123(16) 0123(16) OFED(16) CFED(16) FFED(16)

20EE(16) ; 77(16) = 119 = ( 256 - 18 ) 12 , F7(16) = -9

21FF(16) , FF(16) , FF(16) ,

Z = 1100(2) = 12

Z = Z ShI 1 = 11000(2)

X = Z = 11000(2)

X = X ShI 2 = 1100000(2)

X = X + Z = 1111000(2) = 120













